{"version":3,"sources":["Board.js","symbol-helper.js","index.js"],"names":["createBoard","cols","rows","words","cellChars","ws","WordSearch","dictionary","disabledDirections","y","x","grid","checkedWords","marked","checked","listeners","getChecked","isMarked","includes","unMark","length","isChecked","pos","getRows","getCols","getChar","addListener","l","push","mark","notify","word","forEach","check","invertedWord","markPos","toUpperCase","this","createBoardRenderer","board","cellSize","margin","checkedColors","verts","render","batch","whiteTex","text","begin","setColor","cellY","cellX","fillRect","draw","i","checkedWord","Math","random","minPos","min","maxPos","max","minX","minY","floor","maxX","maxY","drawPolygon","end","createBoardHandler","inputHandler","direction","startCellX","startCellY","addEventListener","getTouchedWorldCoord","touchedX","touchedY","isTouched","undefined","ALL_SYMBOLS","Object","keys","SYMBOLS_DATA","filter","s","slice","getRandomSymbols","n","sort","emitter","EventEmitter","init","canvas","symbols","a","viewport","createViewport","gl","getContext","camera","getCamera","createViewportAwareInputHandler","createBatch","whiteTexture","createWhiteTexture","loadFont","font","createRenderer","setAlignMode","AlignMode","center","console","log","boardRenderer","emit","clearColor","createGameLoop","delta","clear","COLOR_BUFFER_BIT","setProjection","combined","CrossWord","canvasRef","useRef","useEffect","gamePromise","current","then","game","stop","ref","countChecked","checkedCount","k","App","useState","time","setTime","score","setScore","setWords","setChecked","setTimeout","randomNewWords","useCallback","subscription","remove","playAgain","className","onClick","map","symbol","key","getSymbolName","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.2385cf10.chunk.js","sourcesContent":["import { drawPolygon, fillRect } from 'gdxjs';\nimport * as WordSearch from '@blex41/word-search';\n\nexport const createBoard = (cols, rows, words = []) => {\n  const cellChars = [];\n\n  const ws = new WordSearch({\n    cols,\n    rows,\n    dictionary: words,\n    disabledDirections: ['N', 'W', 'NE', 'NW', 'SE', 'SW']\n  });\n\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      cellChars[y * cols + x] = ws.grid[y][x];\n    }\n  }\n\n  const checkedWords = [];\n  const marked = [];\n  const checked = [];\n\n  const listeners = [];\n\n  return {\n    getChecked() {\n      return checked;\n    },\n    isMarked(x, y) {\n      return marked.includes(y * cols + x);\n    },\n    unMark() {\n      marked.length = 0;\n    },\n    isChecked(x, y) {\n      const pos = y * cols + x;\n      for (let line of checked) {\n        if (line.includes(pos)) {\n          return true;\n        }\n      }\n      return false;\n    },\n    getRows() {\n      return rows;\n    },\n    getCols() {\n      return cols;\n    },\n    getChar(x, y) {\n      return cellChars[y * cols + x];\n    },\n    addListener(l) {\n      listeners.push(l);\n    },\n    mark(x, y) {\n      if (x >= cols || y >= rows) return;\n      const pos = y * cols + x;\n      if (marked.includes(pos)) return;\n      marked.push(pos);\n    },\n    notify(word) {\n      listeners.forEach(l => l(word));\n    },\n    check() {\n      let word = '';\n      let invertedWord = '';\n      for (let markPos of marked) {\n        word += cellChars[markPos];\n        invertedWord = cellChars[markPos] + invertedWord;\n      }\n      word = word.toUpperCase();\n      invertedWord = word.toUpperCase();\n      if (words.includes(word) && !checkedWords.includes(word)) {\n        checked.push([...marked]);\n        checkedWords.push(word);\n        this.notify(word);\n      }\n      if (words.includes(invertedWord) && !checkedWords.includes(invertedWord)) {\n        checked.push([...marked]);\n        checkedWords.push(invertedWord);\n        this.notify(word);\n      }\n      marked.length = 0;\n    }\n  };\n};\n\nexport const createBoardRenderer = (board, x, y, cellSize, margin) => {\n  const checkedColors = [\n    [0.808, 0.169, 0.149, 1],\n    [0.502, 0.078, 0.161, 1],\n    [0.392, 0.051, 0.035, 1],\n    [0.329, 0.231, 0.047, 1],\n    [0.047, 0.451, 0.09, 1]\n  ];\n  const verts = [];\n  return {\n    render(batch, whiteTex, text) {\n      const cols = board.getCols();\n      const rows = board.getRows();\n      batch.begin();\n\n      batch.setColor(1, 1, 1, 1);\n      for (let cellY = 0; cellY < rows; cellY++) {\n        for (let cellX = 0; cellX < cols; cellX++) {\n          batch.setColor(1, 1, 1, 1);\n          if (board.isMarked(cellX, cellY)) {\n            batch.setColor(0.5, 0.5, 0.5, 1);\n          } else if (board.isChecked(cellX, cellY)) {\n            batch.setColor(0.7, 0.7, 0.7, 1);\n          }\n          fillRect(\n            batch,\n            whiteTex,\n            x + cellX * (cellSize + margin),\n            y + cellY * (cellSize + margin),\n            cellSize,\n            cellSize\n          );\n        }\n      }\n      for (let cellY = 0; cellY < rows; cellY++) {\n        for (let cellX = 0; cellX < cols; cellX++) {\n          text.draw(\n            batch,\n            board.getChar(cellX, cellY),\n            x + cellX * (cellSize + margin),\n            y + cellY * (cellSize + margin) + cellSize / 4,\n            cellSize / 2\n          );\n        }\n      }\n      let i = 0;\n      for (let checkedWord of board.getChecked()) {\n        if (!checkedColors[i]) {\n          checkedColors[i] = [Math.random(), Math.random(), Math.random(), 1];\n        }\n        // batch.setColor(...checkedColors[i]);\n\n        const minPos = Math.min(...checkedWord);\n        const maxPos = Math.max(...checkedWord);\n\n        let minX = minPos % cols;\n        let minY = Math.floor(minPos / cols);\n\n        let maxX = maxPos % cols;\n        let maxY = Math.floor(maxPos / cols);\n\n        minX = x + minX * (cellSize + margin) + margin;\n        minY = y + minY * (cellSize + margin) + margin;\n\n        maxX = x + (maxX + 1) * (cellSize + margin) - 2 * margin;\n        maxY = y + (maxY + 1) * (cellSize + margin) - 2 * margin;\n\n        verts.length = 0;\n        verts.push(minX, minY);\n        verts.push(minX, maxY);\n        verts.push(maxX, maxY);\n        verts.push(maxX, minY);\n\n        drawPolygon(batch, whiteTex, verts, 5, ...checkedColors[i]);\n        // for (let cell of checkedWord) {\n        //   const cellX = cell % cols;\n        //   const cellY = Math.floor(cell / cols);\n        //   fillRect(\n        //     batch,\n        //     whiteTex,\n        //     x + cellX * (cellSize + margin) - margin,\n        //     y + cellY * (cellSize + margin) - margin,\n        //     cellSize + margin * 2,\n        //     cellSize + margin * 2\n        //   );\n        // }\n        i++;\n      }\n      batch.end();\n    }\n  };\n};\n\nexport const createBoardHandler = (board, x, y, cellSize, margin, inputHandler) => {\n  const cols = board.getCols();\n  const rows = board.getRows();\n  let direction;\n  let startCellX, startCellY;\n  inputHandler.addEventListener('touchStart', () => {\n    const { x: touchedX, y: touchedY } = inputHandler.getTouchedWorldCoord();\n    const cellX = Math.floor((touchedX - x) / (cellSize + margin));\n    const cellY = Math.floor((touchedY - y) / (cellSize + margin));\n    board.mark(cellX, cellY);\n    startCellX = cellX;\n    startCellY = cellY;\n  });\n  inputHandler.addEventListener('touchMove', () => {\n    if (!inputHandler.isTouched()) return;\n    const { x: touchedX, y: touchedY } = inputHandler.getTouchedWorldCoord();\n    let cellX = Math.floor((touchedX - x) / (cellSize + margin));\n    let cellY = Math.floor((touchedY - y) / (cellSize + margin));\n\n    cellX = Math.max(0, Math.min(cols, cellX));\n    cellY = Math.max(0, Math.min(rows, cellY));\n\n    if (cellX > startCellX || cellX < startCellX) {\n      direction = 'horizontal';\n    } else if (cellY > startCellY || cellY < startCellY) {\n      direction = 'vertical';\n    } else if (cellX === startCellX && cellY === startCellY) {\n      direction = undefined;\n    }\n    board.unMark();\n    if (direction === 'horizontal') {\n      for (let x = Math.min(startCellX, cellX); x <= Math.max(startCellX, cellX); x++) {\n        board.mark(x, startCellY);\n      }\n    } else if (direction === 'vertical') {\n      for (let y = Math.min(startCellY, cellY); y <= Math.max(startCellY, cellY); y++) {\n        board.mark(startCellX, y);\n      }\n    } else {\n      board.mark(startCellX, startCellY);\n    }\n  });\n  inputHandler.addEventListener('touchEnd', () => {\n    board.check();\n    direction = undefined;\n    startCellX = undefined;\n    startCellY = undefined;\n  });\n};\n","import SYMBOLS_DATA from './symbols.json';\n\nconst ALL_SYMBOLS = Object.keys(SYMBOLS_DATA)\n  .filter(s => s.length <= 3)\n  .slice(0, 100);\n\nexport const getRandomSymbols = n => ALL_SYMBOLS.sort(() => Math.random() - Math.random()).slice(0, n);\nexport const getSymbolName = symbol => SYMBOLS_DATA[symbol];\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport './index.css';\nimport ReactDOM from 'react-dom';\n\nimport { EventEmitter } from 'fbemitter';\n\nimport {\n  AlignMode,\n  createBatch,\n  createGameLoop,\n  createViewport,\n  createViewportAwareInputHandler,\n  createWhiteTexture,\n  loadFont\n} from 'gdxjs';\nimport { createBoard, createBoardHandler, createBoardRenderer } from './Board';\n\nimport { getRandomSymbols, getSymbolName } from './symbol-helper';\n\nconst emitter = new EventEmitter();\n\nconst init = async (canvas, symbols) => {\n  const viewport = createViewport(canvas, 400, 400);\n  const gl = viewport.getContext();\n  const camera = viewport.getCamera();\n\n  const inputHandler = createViewportAwareInputHandler(canvas, viewport);\n\n  const batch = createBatch(gl);\n  const whiteTexture = createWhiteTexture(gl);\n  const font = await loadFont(gl, './text.fnt');\n  const text = font.createRenderer(72);\n  text.setAlignMode(AlignMode.center);\n\n  console.log(symbols);\n  const board = createBoard(5, 5, symbols);\n  const boardRenderer = createBoardRenderer(board, 10, 10, 72, 5);\n  createBoardHandler(board, 10, 10, 72, 5, inputHandler);\n\n  board.addListener(word => emitter.emit('checked', word));\n\n  gl.clearColor(0.133, 0.133, 0.133, 1);\n  return createGameLoop(delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    batch.setProjection(camera.combined);\n    boardRenderer.render(batch, whiteTexture, text);\n  });\n};\n\nconst CrossWord = ({ words }) => {\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const gamePromise = init(canvasRef.current, words);\n    return () => gamePromise.then(game => game.stop());\n  }, [canvasRef, words]);\n  return <canvas ref={canvasRef}></canvas>;\n};\n\nconst countChecked = checked => {\n  let checkedCount = 0;\n  for (let k in checked) {\n    if (checked[k]) checkedCount++;\n  }\n  return checkedCount;\n};\n\nconst GAME_TIME = 60;\n\nconst App = () => {\n  const [time, setTime] = useState(GAME_TIME);\n  const [score, setScore] = useState(0);\n  const [words, setWords] = useState(getRandomSymbols(4));\n  const [checked, setChecked] = useState({});\n\n  useEffect(() => {\n    if (time <= 0) {\n      return;\n    }\n    setTimeout(() => {\n      setTime(time - 1);\n    }, 1000);\n  }, [time]);\n\n  const randomNewWords = useCallback(() => {\n    setWords(getRandomSymbols(4));\n    const checkedCount = countChecked(checked);\n    if (checkedCount >= 4) {\n      setScore(score + 5);\n    }\n    setChecked({});\n  }, [score, checked]);\n\n  useEffect(() => {\n    const subscription = emitter.addListener('checked', word => {\n      setChecked({\n        ...checked,\n        [word]: true\n      });\n      setScore(score + 5);\n    });\n    return () => subscription.remove();\n  }, [checked, score]);\n\n  const playAgain = useCallback(() => {\n    setChecked({});\n    setScore(0);\n    setTime(GAME_TIME);\n    setWords(getRandomSymbols(4));\n  }, []);\n\n  if (time <= 0) {\n    return (\n      <div className=\"control center\">\n        <div>\n          <strong>Your score: </strong> {score}\n        </div>\n        <button onClick={playAgain}>Play again</button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"wrapper\">\n      <CrossWord words={words} />\n      <div className=\"control\">\n        <div className=\"left controls\">\n          <div>\n            <strong>Score: </strong> {score}\n          </div>\n          <div>\n            <strong>Time: </strong> {time}\n          </div>\n        </div>\n        <hr />\n        Tìm mã giao dịch của {words.length} công ty sau\n        <ul>\n          {words.map(symbol => (\n            <li key={symbol} className={checked[symbol] ? 'checked' : null}>\n              {getSymbolName(symbol)}\n            </li>\n          ))}\n        </ul>\n        <button onClick={randomNewWords}>{countChecked(checked) >= 4 ? 'New (+5)' : 'Skip'}</button>\n      </div>\n    </div>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}